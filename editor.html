<link rel="stylesheet" href="./grid.css">

<style>
  #ui {
    position: absolute;
    top: 0;
    right: 0;
    width: 140px;
  }
  .grid {
    display: grid;
    grid-template-columns: 64px 64px;
  }
</style>

<body>
  <div id="world">
    <canvas id="canvas"></canvas>
  </div>
  <div id="ui">
    Tiles
    <div id="tiles" class="grid"></div>
    Entities
    <div id="entities" class="grid"></div>
  </div>
</body>

<script type="module">
  import * as Constants from './src/Constants.js';
  import { Canvas } from './src/common/Canvas.js';
  import { Tiles } from './src/Tiles.js';
  import { Direction } from './src/Entity.js';
  import { Entities } from './src/Entities.js';
  import { Froggy } from './src/Froggy.js';
  import { World } from './src/World.js';

  import { FroggerCanvas } from './src/FroggerCanvas.js';
  

  World.DebugGrid = true;
  

  const worldCanvas = new FroggerCanvas( document.getElementById( 'canvas' ) );
  worldCanvas.showCropped = true;

  let world = World.fromString( localStorage.getItem( 'currentLevel' ) ) ?? new World( { cols: 15, rows: 15 } );
  worldCanvas.setWorld( world );
  
  
  function redraw() {
    worldCanvas.redraw();

    // Save progress
    localStorage.setItem( 'currentLevel', JSON.stringify( world.toJson() ) );
  }

  redraw();

  let activeBrush = 'Grass', activeType = 'Tiles';
  
  const worldDiv = document.getElementById( 'world' );

  const uiDiv = document.getElementById( 'ui' );

  const tilesDiv = document.getElementById( 'tiles' );
  for ( const tile in Tiles ) {
    const button = document.createElement( 'button' );

    // TODO: Use AnimatedCanvas for these, and just don't start it?
    const icon = new Canvas( 48, 48 );
    icon.ctx.scale( 48, 48 );
    icon.ctx.translate( 0.5, 0.5 );
    Tiles[ tile ].draw( icon.ctx );
    button.appendChild( icon.canvas );
    button.appendChild( document.createElement( 'br' ) );

    const text = document.createElement( 'div' );
    text.innerHTML = tile;
    button.appendChild( text );

    button.addEventListener( 'click', ( e ) => { 
      activeBrush = tile;
      activeType = 'Tiles';
    } );
    tilesDiv.appendChild( button );
  }

  // TODO: Combine similar code with above?
  const entitiesDiv = document.getElementById( 'entities' );
  for ( const id in Entities ) {
    const button = document.createElement( 'button' );

    const icon = new Canvas( 48, 48 );
    icon.ctx.scale( 48, 48 );
    icon.ctx.translate( 0.5, 0.5 );
    icon.ctx.lineWidth = 1 / 48;
    Entities[ id ].drawEntity( icon.ctx );
    button.appendChild( icon.canvas );
    button.appendChild( document.createElement( 'br' ) );

    const text = document.createElement( 'div' );
    text.innerHTML = id;
    button.appendChild( text );

    button.addEventListener( 'click', ( e ) => { 
      activeBrush = id;
      activeType = 'Entities';
    } );
    entitiesDiv.appendChild( button );
  }

  const warpButton = document.createElement( 'button' );
  warpButton.textContent = 'Warp';
  warpButton.addEventListener( 'click', ( e ) => {
    activeBrush = activeType = 'warp';
  } );
  uiDiv.appendChild( warpButton );

  const playerButton = document.createElement( 'button' );
  playerButton.textContent = 'Player';
  playerButton.addEventListener( 'click', ( e ) => {
    activeBrush = activeType = 'player';
  } );
  uiDiv.appendChild( playerButton );

  uiDiv.appendChild( document.createTextNode( 'Crop: ' ) );

  const cropUI = [];
  [ 'minCol', 'minRow', 'maxCol', 'maxRow' ].forEach( val => {
    const numInputUI = document.createElement( 'input' );
    numInputUI.type = 'number';
    numInputUI.style.width = 50;
    numInputUI.oninput = _ => {
      world.crop[ val ] = parseInt( numInputUI.value );
      levelResized()
    };

    cropUI[ val ] = numInputUI;

    uiDiv.appendChild( numInputUI );
  } );
  updateCropUI();

  uiDiv.appendChild( document.createTextNode( 'Time: ' ) );

  const timeUI = document.createElement( 'input' );
  timeUI.type = 'number';
  timeUI.style.width = 70;
  timeUI.value = world.maxTime;
  timeUI.oninput = _ => world.maxTime = parseInt( timeUI.value );
  uiDiv.appendChild( timeUI );
  uiDiv.appendChild( document.createTextNode( 'ms' ) );
  

  const loadInput = document.createElement( 'input' );
  loadInput.type = 'file';
  loadInput.onchange = _ => {
    const reader = new FileReader();
    reader.onload = loadLevel;
    reader.readAsText( loadInput.files[ 0 ] );
  }

  const fileDiv = document.createElement( 'div' );
 
  makeButton( 'Clear', clearLevel, fileDiv );
  makeButton( 'Load', _ => loadInput.click(), fileDiv );
  makeButton( 'Save', saveLevel, fileDiv );
  makeButton( 'Play', _ => worldCanvas.start(), fileDiv );
  makeButton( 'Pause', _ => worldCanvas.stop(), fileDiv );
  makeButton( 'Stop', restoreLevel, fileDiv );

  uiDiv.appendChild( fileDiv );

  function makeButton( text, func, parent ) {
    const button = document.createElement( 'button' );
    button.textContent = text;
    button.addEventListener( 'click', func );
    parent.appendChild( button );
  }

  function updateCropUI() {
    for ( const val in world.crop ) {
      cropUI[ val ].value = world.crop[ val ];
    }

    cropUI.minCol.min = 0;
    cropUI.minCol.max = world.crop.maxCol;
    cropUI.maxCol.min = world.crop.minCol;
    cropUI.maxCol.max = world.cols - 1;
    cropUI.minRow.min = 0;
    cropUI.minRow.max = world.crop.maxRow;
    cropUI.maxRow.min = world.crop.minRow;
    cropUI.maxRow.max = world.rows - 1;
  }
  

  let mouseCol = 0, mouseRow = 0, mouseDown = false, mouseButton = 0;
  let lastCol, lastRow;
  let warpStart;

  worldCanvas.canvas.addEventListener( 'mousemove', ( e ) => {
    mouseCol = Math.floor( e.offsetX / Constants.TileSize );
    mouseRow = Math.floor( e.offsetY / Constants.TileSize );

    if ( mouseDown && activeBrush == 'warp') {
      // TODO: Draw warp-in-progress?
    }

    doMouse();
  } );

  worldCanvas.canvas.addEventListener( 'mousedown', ( e ) => {
    mouseDown = true;
    mouseButton = e.button;

    if ( activeBrush == 'warp' ) {
      warpStart ??= { col: mouseCol, row: mouseRow };
    }

    doMouse();
  } );

  worldCanvas.canvas.addEventListener( 'mouseup', ( e ) => {
    mouseDown = false;
    mouseButton = null;
    lastCol = lastRow = null;

    if ( activeBrush == 'warp' ) {
      world.setWarp( warpStart.col, warpStart.row, mouseCol, mouseRow );
      warpStart = null;
      redraw();
    }
  } );

  // TODO: Moving entities with Click-Drag?
  // (how do I know not to change the tile instead? modifier key?)

  function doMouse() {
    if ( mouseDown && ( mouseCol != lastCol || mouseRow != lastRow ) ) {
      lastCol = mouseCol;
      lastRow = mouseRow;

      if ( mouseButton == 0 ) { 
        if ( activeType == 'Tiles' ) {
          world.tiles[ mouseCol ][ mouseRow ].tileInfoKey = activeBrush;
        }
        else if ( activeType == 'Entities' ) {
          world.addEntity( activeBrush, mouseCol, mouseRow );
        }
        else if ( activeBrush == 'player' ) {
          world.player.x = world.spawnCol = mouseCol;
          world.player.y = world.spawnRow = mouseRow;
        }
      }
      else if ( mouseButton == 2 ) {
        world.removeEntity( mouseCol, mouseRow );
      }

      redraw();
    }
  }

  const KeyBindings = {
    KeyW: () => setDirection( Direction.Up ),
    KeyA: () => setDirection( Direction.Left ),
    KeyS: () => setDirection( Direction.Down ),
    KeyD: () => setDirection( Direction.Right ),
    Space: () => setDirection( null ),
    KeyG: toggleGrid,
    KeyC: () => resize( 1, 0 ),
    KeyX: () => resize( -1, 0 ),
    KeyR: () => resize( 0, 1 ),
    KeyE: () => resize( 0, -1 ),
  };

  document.addEventListener( 'keydown', e => KeyBindings[ e.code ]?.() );

  

  function clearLevel() {
    world = new World( { cols: 17, rows: 17, crop: [ 1, 1, 15, 15 ] } );
    worldCanvas.setWorld( world );
    levelResized();
  }

  function loadLevel( e ) {
    world = World.fromString( e.target.result );
    worldCanvas.setWorld( world );
    levelResized();
  }

  function restoreLevel() {
    worldCanvas.stop();
    world = World.fromString( localStorage.getItem( 'currentLevel' ) );
    worldCanvas.setWorld( world );
    redraw();
  }

  function saveLevel() {
    const filename = 'level.json';
    const content = JSON.stringify( world.toJson() );
    const blob = new Blob( [ content ], { type: 'text/plain' } );
    const link = document.createElement( 'a' );
    link.download = filename;
    link.href = window.URL.createObjectURL( blob );
    document.body.appendChild( link );  // TODO: do we need this?
    link.click();
    // should we do this at some point?
    // document.body.removeChild( link );
    // window.URL.revokeObjectURL( link.href );
  }

  function setDirection( dir ) {
    world.setDirection( dir, mouseCol, mouseRow );
    world.clearWarp( mouseCol, mouseRow );
    redraw();
  }

  function toggleGrid() {
    World.DebugGrid = !World.DebugGrid;
    redraw();
  }

  function resize( cols, rows ) {
    // TODO: multiple?
    if ( cols > 0 )   world.addColumn( mouseCol );
    if ( cols < 0 )   world.removeColumn( mouseCol );
    if ( rows > 0 )   world.addRow( mouseRow ); 
    if ( rows < 0 )   world.removeRow( mouseRow );

    levelResized();
  }
  
  function levelResized() {
    worldCanvas.setSize( world.cols * Constants.TileSize, world.rows * Constants.TileSize );
    updateCropUI();
    redraw();
  }

</script>
