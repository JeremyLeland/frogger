<link rel="stylesheet" href="./grid.css">

<style>
  #wrapper {
    display: grid;
    grid-template-columns: auto 140px;
    max-width: 100vw;
    max-height: 100vh;
  }
  #world {
    overflow: auto;
    max-height: 100vh;
  }
  #ui {
    /* position: absolute; */
    /* top: 0; */
    /* right: 0; */
    /* width: 140px; */
    overflow: auto;
    max-height: 100vh;
  }
  .grid {
    display: grid;
    grid-template-columns: 64px 64px;
  }
</style>

<body>
  <div id="wrapper">
    <div id="world">
      <canvas id="canvas"></canvas>
    </div>
    <div id="ui">
      Tiles
      <div id="tiles" class="grid"></div>
      Directions
      <button id="paths" data-type="Path">Path</button>
      <div id="dirs"></div>
      Entities
      <div id="entities" class="grid"></div>
    </div>
  </div>
</body>

<script type="module">
  import { Constants } from './src/Constants.js';
  import { Canvas } from './src/common/Canvas.js';
  import { Tiles } from './src/Tiles.js';
  import { Direction, Dir } from './src/Entity.js';
  import { Entities } from './src/Entities.js';
  import { Entity } from './src/Entity.js';
  import { Froggy } from './src/Froggy.js';
  import { Level } from './src/Level.js';
  import { World } from './src/World.js';

  import { AnimatedCanvas } from './src/common/AnimatedCanvas.js';
  import { FroggerCanvas } from './src/FroggerCanvas.js';
  
  const TILE_SIZE = 48;
  const EditorLevelKey = 'froggerEditorLevel'

  Level.DebugGrid = true;

  const Mode = { Edit: 0, Play: 1 };
  let mode = Mode.Edit;

  const EditType = { Tiles: 'Tiles', Directions: 'Path', Entities: 'Entities' };
  let activeBrush = 'Grass', activeType = EditType.Tiles;

  const EmptyLevel = new Level();
  EmptyLevel.setSize( 15, 15 );
  EmptyLevel.spawn = { x: 7, y: 7, dir: 0 };

  const level = Object.assign( EmptyLevel, JSON.parse( localStorage.getItem( EditorLevelKey ) ) );

  const canvas = new AnimatedCanvas( 100, 100, document.getElementById( 'canvas' ) );

  canvas.draw = ( ctx ) => {
    ctx.scale( 48, 48 );
    ctx.translate( 0.5, 0.5 );

    level.draw( ctx );
    level.entities.forEach( entity =>
      Entity.draw( entity, ctx, { dir: level.directions[ entity.x + entity.y * level.cols ] } )
    );
  }
  
  // canvas.redraw();

  // const worldCanvas = new FroggerCanvas( document.getElementById( 'canvas' ) );
  // worldCanvas.showUI = false;
  // worldCanvas.scale = 48;

  

  // const world = new World( level );
  // worldCanvas.world = world; 

  //
  // Load/Save/Clear
  //
  function clearLevel() {
    // world = new World( { cols: 15, rows: 15 } );
    // worldCanvas.world = world;
    levelResized();
  }

  function loadLevel() {
    loadInput.click();
  }

  function saveLevel() {
    const filename = 'level.json';
    const content = JSON.stringify( world );
    const blob = new Blob( [ content ], { type: 'text/plain' } );
    const link = document.createElement( 'a' );
    link.download = filename;
    link.href = window.URL.createObjectURL( blob );
    document.body.appendChild( link );  // TODO: do we need this?
    link.click();
    // should we do this at some point?
    // document.body.removeChild( link );
    // window.URL.revokeObjectURL( link.href );
  }

  //
  // Playback
  //
  // function startPlay() {
  //   mode = Mode.Play;
  //   worldCanvas.start();
  // }

  // function pausePlay() {
  //   worldCanvas.stop();
  // }

  // function stopPlay() {
  //   mode = Mode.Edit;
  //   worldCanvas.stop();
  //   world = new World( level );
  //   worldCanvas.world = world;
  //   redraw();
  // }

  let currentDirection = Direction.None;

  function setDirection( dir ) {
    level.setDirection( mouseCol, mouseRow, dir );
    redraw();
  }

  function toggleGrid() {
    World.DebugGrid = !World.DebugGrid;
    redraw();
  }

  function resize( cols, rows ) {
    // TODO: multiple?
    if ( cols > 0 )   world.addColumn( mouseCol );
    if ( cols < 0 )   world.removeColumn( mouseCol );
    if ( rows > 0 )   world.addRow( mouseRow ); 
    if ( rows < 0 )   world.removeRow( mouseRow );

    levelResized();
  }
  
  function levelResized() {
    canvas.setSize( level.cols * TILE_SIZE, level.rows * TILE_SIZE );
    redraw();
  }
  
  function redraw() {
    canvas.redraw();

    // Save progress
    localStorage.setItem( EditorLevelKey, JSON.stringify( level ) );
  }


  
  
  const worldDiv = document.getElementById( 'world' );

  const uiDiv = document.getElementById( 'ui' );

  const tilesDiv = document.getElementById( 'tiles' );
  for ( const tile in Tiles ) {
    tilesDiv.appendChild( getCanvasButton( Tiles[ tile ].draw, tile, 'Tiles' ) );
  }

  const entitiesDiv = document.getElementById( 'entities' );
  for ( const id in Entities ) {
    entitiesDiv.appendChild( getCanvasButton( Entities[ id ].draw, id, 'Entities' ) );
  }

  function getCanvasButton( drawFunc, brush, type ) {
    const button = document.createElement( 'button' );

    // TODO: Use AnimatedCanvas for these, and just don't start it?
    const icon = new Canvas( 48, 48 );
    icon.ctx.scale( 48, 48 );
    icon.ctx.translate( 0.5, 0.5 );
    icon.ctx.lineWidth = 1 / 48;          // TODO: Can we set this once and not deal with it anymore? bug #38
    drawFunc( icon.ctx );
    button.appendChild( icon.canvas );
    button.appendChild( document.createElement( 'br' ) );

    const text = document.createElement( 'div' );
    text.innerHTML = brush;
    button.appendChild( text );

    button.dataset.brush = brush;
    button.dataset.type = type;

    return button;
  }

  const playerButton = document.createElement( 'button' );
  playerButton.textContent = 'Player';
  playerButton.addEventListener( 'click', ( e ) => {
    activeBrush = activeType = 'player';
  } );
  uiDiv.appendChild( playerButton );

  uiDiv.appendChild( document.createTextNode( 'Time: ' ) );

  const timeUI = document.createElement( 'input' );
  timeUI.type = 'number';
  timeUI.style.width = 70;
  timeUI.value = world.maxTime;
  timeUI.oninput = _ => world.maxTime = parseInt( timeUI.value );
  uiDiv.appendChild( timeUI );
  uiDiv.appendChild( document.createTextNode( 'ms' ) );
  

  const loadInput = document.createElement( 'input' );
  loadInput.type = 'file';
  loadInput.onchange = _ => {
    const reader = new FileReader();
    reader.onload = ( e ) => {
      // world = World.fromString( e.target.result );
      // worldCanvas.world = world;
      levelResized();
    };
    reader.readAsText( loadInput.files[ 0 ] );
  }

  const fileDiv = document.createElement( 'div' );
 
  makeButton( 'Clear', clearLevel, fileDiv );
  makeButton( 'Load', loadLevel, fileDiv );
  makeButton( 'Save', saveLevel, fileDiv );
  // makeButton( 'Play', startPlay, fileDiv );
  // makeButton( 'Pause', pausePlay, fileDiv );
  // makeButton( 'Stop', stopPlay, fileDiv );

  uiDiv.appendChild( fileDiv );

  uiDiv.addEventListener( 'click', e => {
    const button = e.target.closest( 'button' );
    activeBrush = button.dataset.brush;
    activeType = button.dataset.type;
  } );

  function makeButton( text, func, parent ) {
    const button = document.createElement( 'button' );
    button.textContent = text;
    button.addEventListener( 'click', func );
    parent.appendChild( button );
  }

  let mouseCol = 0, mouseRow = 0, mouseDown = false, mouseButton = 0;
  let lastCol, lastRow;

  canvas.canvas.addEventListener( 'pointermove', ( e ) => {
    mouseCol = Math.floor( e.offsetX / Constants.TileSize );
    mouseRow = Math.floor( e.offsetY / Constants.TileSize );

    doMouse();
  } );

  canvas.canvas.addEventListener( 'pointerdown', ( e ) => {
    mouseDown = true;
    mouseButton = e.button;

    doMouse();
  } );

  canvas.canvas.addEventListener( 'pointerup', ( e ) => {
    mouseDown = false;
    mouseButton = null;
    lastCol = lastRow = null;
  } );

  // TODO: Moving entities with Click-Drag?
  // (how do I know not to change the tile instead? modifier key?)

  function doMouse() {
    if ( mode == Mode.Edit && mouseDown && ( mouseCol != lastCol || mouseRow != lastRow ) ) {
      if ( mouseButton == 0 ) {
        // TODO: switch/case instead of ifs?
        // TODO: enum for activeType?
        if ( activeType == EditType.Tiles ) {
          level.setTileInfo( mouseCol, mouseRow, activeBrush );
        }
        else if ( activeType == EditType.Directions ) {
          if ( lastCol != null && lastRow != null ) {
            const dx = mouseCol - lastCol;
            const dy = mouseRow - lastRow;
            const dir = Dir.findIndex( e => e.x == dx && e.y == dy );
            
            level.setDirection( lastCol, lastRow, dir );
            level.setDirection( mouseCol, mouseRow, dir );
          }
        }
        else if ( activeType == EditType.Entities ) {
          level.removeEntity( mouseCol, mouseRow );

          if ( activeBrush == 'Player' ) {
            level.spawn = { x: mouseCol, y: mouseRow, dir: 1 };
          }
          else {
            level.addEntity( mouseCol, mouseRow, activeBrush );
          }
        }
        
      }
      else if ( mouseButton == 2 ) {
        // if ( activeType == EditType.Tiles ) {
        //   level.setTileInfo( mouseCol, mouseRow, level.tileInfoKeys[ 0 ] );
        // }
        if ( activeType == EditType.Directions ) {
          level.setDirection( mouseCol, mouseRow, Direction.None );
        }
        else { //if ( activeType == EditType.Entities ) {
          level.removeEntity( mouseCol, mouseRow );
        }
      }

      lastCol = mouseCol;
      lastRow = mouseRow;

      redraw();
    }
  }

  // TODO: Save keydown state and set direction in doMouse()

  // TODO: Use path tool to set directions
  // TODO: Use WASD to set direction for entity under cursor 

  const KeyBindings = {
    KeyW: () => setDirection( Direction.Up ),
    KeyA: () => setDirection( Direction.Left ),
    KeyS: () => setDirection( Direction.Down ),
    KeyD: () => setDirection( Direction.Right ),
    Space: () => setDirection( null ),
    KeyG: toggleGrid,
    KeyC: () => resize( 1, 0 ),
    KeyX: () => resize( -1, 0 ),
    KeyR: () => resize( 0, 1 ),
    KeyE: () => resize( 0, -1 ),
  };

  document.addEventListener( 'keydown', e => KeyBindings[ e.code ]?.() );


  levelResized();
  // redraw();

</script>
