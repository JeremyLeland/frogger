<style>
  body {
    margin: 0px;
  }
</style>

<body>
  <div id="world"></div>
  <div id="ui">
    <div id="tiles"></div>
    <div id="froggies"></div>
    <div id="entities"></div>
  </div>
</body>

<script type="module">
  import { Canvas } from './src/common/Canvas.js';
  import { Tiles } from './src/Tiles.js';
  import { Direction } from './src/Entity.js';
  import { Entities } from './src/Entities.js';
  import { Froggy } from './src/Froggy.js';
  import { World } from './src/World.js';
  
  const TILE_SIZE = 64;

  World.DebugGrid = true;
  
  const world = await World.fromFile( './levels/test1.json' );
  const worldCanvas = new Canvas( world.cols * TILE_SIZE, world.rows * TILE_SIZE );
  
  function redraw() {
    const ctx = worldCanvas.ctx;

    ctx.save();

    ctx.scale( TILE_SIZE, TILE_SIZE );
    world.draw( ctx );

    ctx.beginPath();
    ctx.moveTo( world.crop.minCol,     world.crop.minRow     );
    ctx.lineTo( world.crop.minCol,     world.crop.maxRow + 1 );
    ctx.lineTo( world.crop.maxCol + 1, world.crop.maxRow + 1 );
    ctx.lineTo( world.crop.maxCol + 1, world.crop.minRow     );
    ctx.lineTo( world.crop.minCol,     world.crop.minRow     );

    ctx.setLineDash( [ 0.1, 0.1 ] );
    ctx.lineWidth = 0.05;
    ctx.stroke();

    ctx.lineTo( 0, 0 );
    ctx.lineTo( world.cols, 0 );
    ctx.lineTo( world.cols, world.rows );
    ctx.lineTo( 0, world.rows );
    ctx.lineTo( 0, 0 );

    ctx.fillStyle = "#000b";
    ctx.fill();

    ctx.restore();
  }

  redraw();

  let activeBrush = Tiles.Grass, activeType = 'Tiles';
  
  const worldDiv = document.getElementById( 'world' );
  worldDiv.appendChild( worldCanvas.canvas );

  const tilesDiv = document.getElementById( 'tiles' );
  tilesDiv.appendChild( document.createTextNode( 'Tiles: ' ) );
  for ( const tile in Tiles ) {
    const button = document.createElement( 'button' );
    button.textContent = tile;
    button.brush = Tiles[ tile ];
    button.addEventListener( 'click', ( e ) => { 
      activeBrush = Tiles[ tile ];
      activeType = 'Tiles';
    } );
    tilesDiv.appendChild( button );
  }

  const froggiesDiv = document.getElementById( 'froggies' );
  froggiesDiv.appendChild( document.createTextNode( 'Froggies: ' ) );
  for ( let i = 0; i < Froggy.Count; i ++ ) {
    const button = document.createElement( 'button' );
    button.textContent = i;
    froggiesDiv.appendChild( button );
  }

  const entitiesDiv = document.getElementById( 'entities' );
  entitiesDiv.appendChild( document.createTextNode( 'Entities: ' ) );
  for ( const type in Entities ) {
    const button = document.createElement( 'button' );
    button.textContent = type;
    button.addEventListener( 'click', ( e ) => { 
      activeBrush = type;
      activeType = 'Cars';
    } );
    entitiesDiv.appendChild( button );
  }

  let mouseCol = 0, mouseRow = 0, mouseDown = false, mouseButton = 0;
  let lastCol, lastRow;

  worldCanvas.canvas.addEventListener( 'mousemove', ( e ) => {
    mouseCol = Math.floor( e.clientX / TILE_SIZE );
    mouseRow = Math.floor( e.clientY / TILE_SIZE );
    doMouse();
  } );

  worldCanvas.canvas.addEventListener( 'mousedown', ( e ) => {
    mouseDown = true;
    mouseButton = e.button;
    doMouse();
  } );

  worldCanvas.canvas.addEventListener( 'mouseup', ( e ) => {
    mouseDown = false;
    mouseButton = null;
    lastCol = lastRow = null;
  } );

  function doMouse() {
    if ( mouseDown && ( mouseCol != lastCol || mouseRow != lastRow ) ) {
      lastCol = mouseCol;
      lastRow = mouseRow;

      if ( mouseButton == 0 ) { 
        if ( activeType == 'Tiles' ) {
          world.tiles[ mouseCol ][ mouseRow ].tileInfo = activeBrush;
        }
        else if ( activeType == 'Cars' ) {
          world.addEntity( activeBrush, mouseCol, mouseRow );
        }
      }
      else if ( mouseButton == 2 ) {
        world.removeEntity( mouseCol, mouseRow );
      }

      redraw();
    }
  }

  const KeyBindings = {
    KeyW: () => setDirection( Direction.Up ),
    KeyA: () => setDirection( Direction.Left ),
    KeyS: () => setDirection( Direction.Down ),
    KeyD: () => setDirection( Direction.Right ),
    Space: () => setDirection( null ),
  };

  document.addEventListener( 'keydown', e => KeyBindings[ e.code ]?.() );

    // TODO: Add col/row
    // TODO: Remove col/row with Shift?

  function setDirection( dir ) {
    world.tiles[ mouseCol ][ mouseRow ].dir = dir;
    redraw();
  }
  

</script>
