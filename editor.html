<style>
  body {
    margin: 0px;
  }
</style>

<body>
  <div id="world"></div>
  <div id="ui">
    <div id="tiles"></div>
    <div id="entities"></div>
  </div>
</body>

<script type="module">
  import { Canvas } from './src/common/Canvas.js';
  import { Tiles } from './src/Tiles.js';
  import { Direction } from './src/Entity.js';
  import { Entities } from './src/Entities.js';
  import { Froggy } from './src/Froggy.js';
  import { World } from './src/World.js';
  
  const TILE_SIZE = 48;

  World.DebugGrid = true;
  
  let world = new World( { cols: 15, rows: 15 } );
  
  const worldCanvas = new Canvas( world.cols * TILE_SIZE, world.rows * TILE_SIZE );
  
  function redraw() {
    const ctx = worldCanvas.ctx;

    ctx.save();

    ctx.scale( TILE_SIZE, TILE_SIZE );
    world.draw( ctx );

    ctx.beginPath();
    ctx.moveTo( world.crop.minCol,     world.crop.minRow     );
    ctx.lineTo( world.crop.minCol,     world.crop.maxRow + 1 );
    ctx.lineTo( world.crop.maxCol + 1, world.crop.maxRow + 1 );
    ctx.lineTo( world.crop.maxCol + 1, world.crop.minRow     );
    ctx.lineTo( world.crop.minCol,     world.crop.minRow     );

    ctx.setLineDash( [ 0.1, 0.1 ] );
    ctx.lineWidth = 0.05;
    ctx.stroke();

    ctx.lineTo( 0, 0 );
    ctx.lineTo( world.cols, 0 );
    ctx.lineTo( world.cols, world.rows );
    ctx.lineTo( 0, world.rows );
    ctx.lineTo( 0, 0 );

    ctx.fillStyle = "#000b";
    ctx.fill();

    ctx.restore();
  }

  redraw();

  let activeBrush = 'Grass', activeType = 'Tiles';
  
  const worldDiv = document.getElementById( 'world' );
  worldDiv.appendChild( worldCanvas.canvas );

  const uiDiv = document.getElementById( 'ui' );

  const tilesDiv = document.getElementById( 'tiles' );
  tilesDiv.appendChild( document.createTextNode( 'Tiles: ' ) );
  for ( const tile in Tiles ) {
    const button = document.createElement( 'button' );
    button.textContent = tile;
    button.addEventListener( 'click', ( e ) => { 
      activeBrush = tile;
      activeType = 'Tiles';
    } );
    tilesDiv.appendChild( button );
  }

  // TODO: Combine similar code with above?
  const entitiesDiv = document.getElementById( 'entities' );
  entitiesDiv.appendChild( document.createTextNode( 'Entities: ' ) );
  for ( const type in Entities ) {
    const button = document.createElement( 'button' );
    button.textContent = type;
    button.addEventListener( 'click', ( e ) => { 
      activeBrush = type;
      activeType = 'Entities';
    } );
    entitiesDiv.appendChild( button );
  }

  const warpButton = document.createElement( 'button' );
  warpButton.textContent = 'Warp';
  warpButton.addEventListener( 'click', ( e ) => {
    activeBrush = activeType = 'warp';
  } );
  uiDiv.appendChild( warpButton );

  const playerButton = document.createElement( 'button' );
  playerButton.textContent = 'Player';
  playerButton.addEventListener( 'click', ( e ) => {
    activeBrush = activeType = 'player';
  } );
  uiDiv.appendChild( playerButton );

  uiDiv.appendChild( document.createTextNode( 'Crop: ' ) );

  const cropUI = [];
  [ 'minCol', 'minRow', 'maxCol', 'maxRow' ].forEach( val => {
    const numInputUI = document.createElement( 'input' );
    numInputUI.type = 'number';
    numInputUI.style.width = 50;
    numInputUI.oninput = _ => {
      world.crop[ val ] = parseInt( numInputUI.value );
      updateCropUI();
      redraw();
    };

    cropUI[ val ] = numInputUI;

    uiDiv.appendChild( numInputUI );
  } );
  updateCropUI();

  uiDiv.appendChild( document.createTextNode( 'Time: ' ) );

  const timeUI = document.createElement( 'input' );
  timeUI.type = 'number';
  timeUI.style.width = 70;
  timeUI.value = world.maxTime;
  timeUI.oninput = _ => world.maxTime = parseInt( timeUI.value );
  uiDiv.appendChild( timeUI );
  uiDiv.appendChild( document.createTextNode( 'ms' ) );
  
  uiDiv.appendChild( document.createTextNode( 'Load: ' ) );

  // TODO: Hidden file input, triggered by Load button
  const loadButton = document.createElement( 'input' );
  loadButton.type = 'file';
  loadButton.onchange = _ => {
    const reader = new FileReader();
    reader.onload = loadLevel;
    reader.readAsText( loadButton.files[ 0 ] );
  }
  uiDiv.appendChild( loadButton );

  uiDiv.appendChild( document.createTextNode( 'Save: ' ) );
  const saveButton = document.createElement( 'button' );
  saveButton.textContent = 'Save';
  saveButton.addEventListener( 'click', saveLevel );
  uiDiv.appendChild( saveButton );

  function updateCropUI() {
    for ( const val in world.crop ) {
      cropUI[ val ].value = world.crop[ val ];
    }

    cropUI.minCol.min = 0;
    cropUI.minCol.max = world.crop.maxCol;
    cropUI.maxCol.min = world.crop.minCol;
    cropUI.maxCol.max = world.cols - 1;
    cropUI.minRow.min = 0;
    cropUI.minRow.max = world.crop.maxRow;
    cropUI.maxRow.min = world.crop.minRow;
    cropUI.maxRow.max = world.rows - 1;
  }
  

  let mouseCol = 0, mouseRow = 0, mouseDown = false, mouseButton = 0;
  let lastCol, lastRow;
  let warpStart;

  worldCanvas.canvas.addEventListener( 'mousemove', ( e ) => {
    mouseCol = Math.floor( e.offsetX / TILE_SIZE );
    mouseRow = Math.floor( e.offsetY / TILE_SIZE );

    if ( mouseDown && activeBrush == 'warp') {
      // TODO: Draw warp-in-progress?
    }

    doMouse();
  } );

  worldCanvas.canvas.addEventListener( 'mousedown', ( e ) => {
    mouseDown = true;
    mouseButton = e.button;

    if ( activeBrush == 'warp' ) {
      warpStart ??= { col: mouseCol, row: mouseRow };
    }

    doMouse();
  } );

  worldCanvas.canvas.addEventListener( 'mouseup', ( e ) => {
    mouseDown = false;
    mouseButton = null;
    lastCol = lastRow = null;

    if ( activeBrush == 'warp' ) {
      world.setWarp( warpStart.col, warpStart.row, mouseCol, mouseRow );
      warpStart = null;
      redraw();
    }
  } );

  // TODO: Moving entities with Click-Drag?
  // (how do I know not to change the tile instead? modifier key?)

  function doMouse() {
    if ( mouseDown && ( mouseCol != lastCol || mouseRow != lastRow ) ) {
      lastCol = mouseCol;
      lastRow = mouseRow;

      if ( mouseButton == 0 ) { 
        if ( activeType == 'Tiles' ) {
          world.tiles[ mouseCol ][ mouseRow ].tileInfoKey = activeBrush;
        }
        else if ( activeType == 'Entities' ) {
          world.addEntity( activeBrush, mouseCol, mouseRow );
        }
        else if ( activeBrush == 'player' ) {
          world.player.x = world.spawnCol = mouseCol;
          world.player.y = world.spawnRow = mouseRow;
        }
      }
      else if ( mouseButton == 2 ) {
        world.removeEntity( mouseCol, mouseRow );
      }

      redraw();
    }
  }

  const KeyBindings = {
    KeyW: () => setDirection( Direction.Up ),
    KeyA: () => setDirection( Direction.Left ),
    KeyS: () => setDirection( Direction.Down ),
    KeyD: () => setDirection( Direction.Right ),
    Space: () => setDirection( null ),
    KeyG: toggleGrid,
    KeyC: () => resize( 1, 0 ),
    KeyX: () => resize( -1, 0 ),
    KeyR: () => resize( 0, 1 ),
    KeyE: () => resize( 0, -1 ),
  };

  document.addEventListener( 'keydown', e => KeyBindings[ e.code ]?.() );

  function loadLevel( e ) {
    world = new World( JSON.parse( e.target.result ) );
    worldCanvas.setSize( world.cols * TILE_SIZE, world.rows * TILE_SIZE );
    updateCropUI();
    redraw();
  }

  function saveLevel() {
    const filename = 'level.json';
    const content = JSON.stringify( world.toJson() );
    const blob = new Blob( [ content ], { type: 'text/plain' } );
    const link = document.createElement( 'a' );
    link.download = filename;
    link.href = window.URL.createObjectURL( blob );
    document.body.appendChild( link );  // TODO: do we need this?
    link.click();
    // should we do this at some point?
    // document.body.removeChild( link );
    // window.URL.revokeObjectURL( link.href );
  }

  function setDirection( dir ) {
    world.setDirection( dir, mouseCol, mouseRow );
    world.clearWarp( mouseCol, mouseRow );
    redraw();
  }

  function toggleGrid() {
    World.DebugGrid = !World.DebugGrid;
    redraw();
  }

  function resize( cols, rows ) {
    // TODO: multiple?
    if ( cols > 0 )   world.addColumn( mouseCol );
    if ( cols < 0 )   world.removeColumn( mouseCol );
    if ( rows > 0 )   world.addRow( mouseRow ); 
    if ( rows < 0 )   world.removeRow( mouseRow );

    updateCropUI();

    worldCanvas.setSize( world.cols * TILE_SIZE, world.rows * TILE_SIZE );
    redraw();
  }
  

</script>
