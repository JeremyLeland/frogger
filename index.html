<title>Frogger v0.6</title>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="./ui.css">
</head>

<style>
  body {
    background-color: #222;
    font-family: cursive;
    font-size: 16px;
  }

  svg {
    position: absolute;
    top: 0;
    background-color: grey;
    width: 100%;
    height: 100%;
  }

  path { 
    fill: transparent;
  }

  text {
    fill: url( #gradient );
    filter: drop-shadow( 0.75px 0.75px 0.1px black );
  }
</style>

<body onunload="">
  <div id="wrapper">
    <div id="game">
      <canvas id="canvas"></canvas>
      <div id="victory" class="message center">
        <span class="bar center">Victory!</span>
      </div>
      <div id="defeat" class="message center">
        <span class="bar center">Defeat!</span>
      </div>
    </div>
    <div id="ui">
      <div id="rescued"></div>
      <div id="timer" class="center">
        <div id="timerBar">
          <div id="timeLeft"></div>
        </div>
      </div>
      <div id="lives"></div>
    </div>
    <div id="paused" class="center">Paused</div>
    <svg id="splash" viewBox="0 0 100 100">
      <defs>
        <radialGradient id="gradient">
          <stop offset="5%" stop-color="green" />
          <stop offset="99%" stop-color="lime" />
        </radialGradient>
      </defs>
      <path id="curve" d="M 25,50 Q 50,25 75,45" />
      <text>
        <textPath xlink:href="#curve">
          Frogger
        </textPath>
      </text>
    </svg>
  </div>
</body>

<script type="module">
  import { Direction } from './src/Entity.js';
  import { World } from './src/World.js';
  import { UI } from './src/UI.js';
  
  import { AnimatedCanvas } from './src/common/AnimatedCanvas.js';

  const TILE_SIZE = 48;

  let world;

  const canvas = new AnimatedCanvas(
    TILE_SIZE,
    TILE_SIZE,
    document.getElementById( 'canvas' )
  );

  const ui = new UI();

  canvas.update = ( dt ) => {
    world.update( dt );
  }
  
  canvas.draw = ( ctx ) => {
    ctx.save();
    ctx.scale( TILE_SIZE, TILE_SIZE );

    ctx.translate( -world.crop.minCol, -world.crop.minRow );

    world.draw( ctx );

    ctx.restore();
  };

  //
  // Levels
  //
  let levelIndex = localStorage.getItem( 'levelIndex' ) ?? 0;
  const levels = [
    './levels/classic/road.json',
    './levels/classic/retro.json',
    './levels/classic/pond.json',
    './levels/classic/median.json',
    './levels/classic/river.json',
    './levels/classic/intersection.json',
    './levels/classic/islands.json',
    './levels/classic/roundabout.json',
    './levels/classic/superhighway.json',
  ];

  const splashUI = document.getElementById( 'splash' );

  async function loadLevel( path ) {
    canvas.stop();

    world = await World.fromFile( path );
    ui.reset();
    world.ui = ui;
    splashUI.style.visibility = 'hidden';
    
    canvas.setSize(
      ( world.crop.maxCol - world.crop.minCol + 1 ) * TILE_SIZE,
      ( world.crop.maxRow - world.crop.minRow + 1 ) * TILE_SIZE,
    );
    canvas.start();
  }

  function restartLevel() {
    loadLevel( levels[ levelIndex ] );
  }

  function prevLevel() {
    levelIndex = Math.max( 0, levelIndex - 1 );
    localStorage.setItem( 'levelIndex', levelIndex );

    loadLevel( levels[ levelIndex ] );
  }
  
  function nextLevel() {
    levelIndex = Math.min( levels.length - 1, levelIndex + 1 );
    localStorage.setItem( 'levelIndex', levelIndex );

    loadLevel( levels[ levelIndex ] );
  }

  // 
  // Movement
  //

  const moveUp =    () => move( Direction.Up );
  const moveDown =  () => move( Direction.Down );
  const moveLeft =  () => move( Direction.Left );
  const moveRight = () => move( Direction.Right );

  function move( dir ) {
    if ( !paused ) {
      if ( !world ) {
        restartLevel();
      }
      if ( world.victory ) {
        nextLevel();
      }
      else if ( world.defeat ) {
        // previousLevel();   // maybe this is too mean
        restartLevel();  // just restart for now
      }
      else if ( world.needsRespawn ) {
        world.respawnPlayer();
      }
      else {
        world.player.move( dir );
      }
    }
  }

  const KeyBindings = {
    KeyW: moveUp,
    KeyA: moveLeft,
    KeyS: moveDown,
    KeyD: moveRight,
    ArrowUp: moveUp,
    ArrowLeft: moveLeft,
    ArrowDown: moveDown,
    ArrowRight: moveRight,
    KeyG: () => World.DebugGrid = !World.DebugGrid,
    KeyN: nextLevel,
    KeyP: prevLevel,
    Space: togglePause
  };

  const pauseUI = document.getElementById( 'paused' );
  let paused = false;
  function togglePause() {
    if ( paused ) {
      paused = false;
      pauseUI.style.visibility = 'hidden';
      canvas.start();
    }
    else {
      paused = true;
      pauseUI.style.visibility = 'visible';
      canvas.stop();
    }
  }

  document.addEventListener( 'keydown', e => KeyBindings[ e.code ]?.() );

</script>