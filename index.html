<title>Frogger</title>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="./grid.css">
</head>

<style>
  body { 
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
  }
  #message {
    visibility: hidden;
    position: absolute;
    
    font-family: cursive;
    text-shadow: 3px 3px black;

    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
  }
  #ui {
    /* position: absolute;
    bottom: 0%; */
    /* visibility: hidden; */
  }
  #big {
    font-size: 70;
  }
  #little {
    font-size: 30;
  }
</style>

<body>
  <div id="message">
    <div id="big">Victory!</div>
    <div id="little">Press any key to continue</div>
  </div>
</body>

<script type="module">
  import { Direction } from './src/Entity.js';
  import { World } from './src/World.js';
  
  import { AnimatedCanvas } from './src/common/AnimatedCanvas.js';

  const TILE_SIZE = 48;

  let world;

  const GameState = {
    Playing: 0,
    Died: 1,
    Win: 2,
    Lose: 3
  };
  let gameState = GameState.Playing;

  const canvas = new AnimatedCanvas(
    TILE_SIZE,
    TILE_SIZE,
  );

  // TODO: use html-based UI for this instead?
  const rescuedCanvas = new AnimatedCanvas(
    15 * TILE_SIZE,
    TILE_SIZE,
  );
  rescuedCanvas.canvas.id = 'ui';

  const messageDiv = document.getElementById( 'message' );
  const bigDiv = document.getElementById( 'big' );

  canvas.update = ( dt ) => {
    world.update( dt );

    // TODO: Don't constantly set this!
    if ( world.victory ) {
      if ( gameState != GameState.Win ) {
        showMessage( 'üèÜ Victory! üèÜ' );
        gameState = GameState.Win;
      }
    }
    else if ( world.timeLeft <= 0 ) {
      if ( gameState != GameState.Died ) {
        showMessage( '‚è∞ Time‚Äôs Up! ‚è∞' );
        gameState = GameState.Died;
      }
    }
    else if ( !world.player.isAlive ) {
      if ( gameState != GameState.Died ) {
        showMessage( 'Oops!' );
        gameState = GameState.Died;
      }
    }
  }
  
  canvas.draw = ( ctx ) => {
    ctx.save();
    ctx.scale( TILE_SIZE, TILE_SIZE );

    ctx.translate( -world.crop.minCol, -world.crop.minRow );

    world.draw( ctx );

    ctx.restore();

    rescuedCanvas.redraw();
  };

  rescuedCanvas.draw = ( ctx ) => {
    ctx.save();
    ctx.scale( TILE_SIZE, TILE_SIZE );

    world.drawUI( ctx );

    ctx.restore();
  }

  //
  // UI
  //

  function showMessage( text ) {
    bigDiv.innerText = text;
    messageDiv.style.visibility = 'visible';
  }

  function hideMessage() {
    messageDiv.style.visibility = 'hidden';
  }

  //
  // Levels
  //
  let levelIndex = 0;
  const levels = [ 
    './levels/classic/road.json',
    './levels/classic/retro.json',
    './levels/classic/pond.json',
    './levels/classic/median.json',
    './levels/classic/river.json',
    './levels/classic/intersection.json',
    './levels/classic/islands.json',
  ];

  loadLevel( levels[ levelIndex ] );

  async function loadLevel( path ) {
    canvas.stop();
    messageDiv.style.visibility = 'hidden';
    // ui.victory.style.visibility = 'hidden';

    world = await World.fromFile( path );
    gameState = GameState.Playing;
    
    canvas.setSize(
      ( world.crop.maxCol - world.crop.minCol + 1 ) * TILE_SIZE,
      ( world.crop.maxRow - world.crop.minRow + 1 ) * TILE_SIZE,
    );
    canvas.start();
  }

  function prevLevel() {
    levelIndex = Math.max( 0, levelIndex - 1 );
    loadLevel( levels[ levelIndex ] );
  }
  
  function nextLevel() {
    levelIndex = Math.min( levels.length - 1, levelIndex + 1 );
    loadLevel( levels[ levelIndex ] );
  }

  // 
  // Movement
  //

  const moveUp =    () => move( Direction.Up );
  const moveDown =  () => move( Direction.Down );
  const moveLeft =  () => move( Direction.Left );
  const moveRight = () => move( Direction.Right );

  function move( dir ) {
    if ( world.victory ) {
      nextLevel();
    }
    else if ( world.needsRespawn ) {
      world.respawnPlayer();
      gameState = GameState.Playing;
      messageDiv.style.visibility = 'hidden';
    }
    else {
      world.player.move( dir );
    }
  }

  const KeyBindings = {
    KeyW: moveUp,
    KeyA: moveLeft,
    KeyS: moveDown,
    KeyD: moveRight,
    ArrowUp: moveUp,
    ArrowLeft: moveLeft,
    ArrowDown: moveDown,
    ArrowRight: moveRight,
    KeyG: () => World.DebugGrid = !World.DebugGrid,
    KeyN: nextLevel,
    KeyP: prevLevel,
  };

  document.addEventListener( 'keydown', e => KeyBindings[ e.code ]?.() );

</script>