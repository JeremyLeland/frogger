<link rel="stylesheet" href="../grid.css">

<script type="module">
  import * as THREE from '../lib/three.module.js';
  import * as MeshDemo from './meshDemo.js';


  const vert = /* glsl */ `
    out vec2 v_pos;

    void main() {
      v_pos = position.xy;
      
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
  `;

  const frag = /* glsl */ `
    #define PI 3.14159265359

    in vec2 v_pos;

    out vec3 outColor;

    uniform int tiles[ 25 ];

    void main() {

      vec2 mapPos = ( v_pos + 0.5 ) * 5.0;

      int tile = tiles[ int( mapPos.x ) + int( mapPos.y ) * 5 ];

      switch ( tile ) {
        case 0: outColor = vec3( 0.0, 1.0, 0.0 ); break;
        case 1: outColor = vec3( 0.0, 0.0, 1.0 ); break;
        case 2: outColor = vec3( 0.3, 0.3, 0.3 ); break;
      }

      float fromCenter = distance( vec2( 0.5 ), fract( mapPos ) );

      if ( fromCenter > 0.5 ) {
        discard;
      }

    }
  `;


  let animationTime = 0;

  const map = new THREE.Mesh(
    new THREE.PlaneGeometry( 1, 1 ),
    new THREE.ShaderMaterial( {
      uniforms: {
        tiles: { value: [
          0, 1, 1, 1, 1,
          2, 0, 2, 1, 0,
          2, 2, 0, 2, 2,
          2, 1, 2, 0, 0,
          2, 0, 2, 0, 0
        ] },
      },
      vertexShader: vert,
      fragmentShader: frag,
      glslVersion: THREE.GLSL3,
    } ),
  );

  map.scale.set( 5, 5, 5 );   // make it easier to see
  
  // NOTE: Will need to flip camera or projection or whatever in final version so 0,0 is upper left (for my sanity)

  const group = new THREE.Group();
  group.add( map );
    
  MeshDemo.meshDemo( 
    group, 
    // ( dt ) => {
    //   animationTime += dt / 500;

    //   logs.forEach( ( log, index ) => log.position.x = index - 1 + Math.sin( animationTime ) );
    // }
  );

</script>
