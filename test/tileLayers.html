<title>Layers per tile</title>
<link rel="stylesheet" href="../grid.css">

<script type="module">
  import { AnimatedCanvas } from '../src/common/AnimatedCanvas.js';
  import * as Utility from '../src/common/Utility.js';

  const canvas = new AnimatedCanvas();

  const TILE_SIZE = 64;
  const colors = [
    'blue',
    'green',
  ];
  const cols = 3, rows = 3;
  const tiles = [
    [ 1, 1, 1 ],
    [ 1, 0, 1 ],
    [ 1, 1, 1 ],
  ];

  // Is this per layer? YES

  const edges = Array.from( 
    Array( cols + 1 ), _ => Array.from( 
      Array( rows + 1 ), _ => null ) );

  // TODO: Should we only be checking left/top or right/bottom to avoid doubling work?
  //       Would need to special case one of the outer edges for this
  
  for ( let row = 0; row < rows; row ++ ) {
    for ( let col = 0; col < cols; col ++ ) {
      // const current = tiles[ col ][ row ];
      const current = 1;

      // Left edge (going down)
      if ( 0 == col || current != tiles[ col - 1 ][ row ] ) {
        edges[ col ][ row ] = [ col, row, col, row + 1 ];
      }

      // Top edge (going left)
      if ( 0 == row || current != tiles[ col ][ row - 1 ] ) {
        edges[ col + 1 ][ row ] = [ col + 1, row, col, row ];
      }

      // Right edge (going up)
      if ( cols == col + 1 || current != tiles[ col + 1 ][ row ] ) {
        edges[ col + 1 ][ row + 1 ] = [ col + 1, row + 1, col + 1, row ];
      }

      // Bottom edge (going right)
      if ( rows == row + 1 || current != tiles[ col ][ row + 1 ] ) {
        edges[ col ][ row + 1 ] = [ col, row + 1, col + 1, row + 1 ];
      }
    }
  }

  const unvisited = new Set();
  const visited = new Set();

  for ( let row = 0; row <= rows; row ++ ) {
    for ( let col = 0; col <= cols; col ++ ) {
      const edge = edges[ col ][ row ];
      if ( edge ) {
        unvisited.add( edge );
      }
    }
  }

  canvas.draw = ( ctx ) => {
    ctx.scale( TILE_SIZE, TILE_SIZE );
    ctx.translate( 1, 1 );
    ctx.lineWidth = 1 / TILE_SIZE;

    const grass = new Path2D();

    while ( unvisited.size > 0 ) {
      let [ edge ] = unvisited;

      while ( !visited.has( edge ) ) {
        unvisited.delete( edge );
        visited.add( edge );
        
        grass.lineTo( edge[ 2 ], edge[ 3 ] );

        edge = edges[ edge[ 2 ] ][ edge[ 3 ] ];
      }

      grass.lineTo( edge[ 0 ], edge[ 1 ] );
      grass.closePath();
    }

    ctx.fillStyle = 'green';
    ctx.fill( grass, 'evenodd' );

    ctx.fillStyle = ctx.lineStyle = 'black';

    for ( let row = 0; row <= rows; row ++ ) {
      for ( let col = 0; col <= cols; col ++ ) {
        const edge = edges[ col ][ row ];
        if ( edge ) {
          Utility.drawArrow( ctx, ...edge );
        }
      }
    }
  }

  canvas.redraw();
</script>