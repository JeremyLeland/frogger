<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebGL Demo</title>
  </head>

  <body>
    <canvas id="glcanvas"></canvas>
  </body>
</html>

<script type="module">
  import { mat4 } from '../lib/gl-matrix.js';

  const width = 800, height = 600;
  const canvas = document.querySelector("#glcanvas");
  canvas.width = width * devicePixelRatio;
  canvas.height = height * devicePixelRatio;
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';

  // Initialize the GL context
  const gl = canvas.getContext("webgl2");

  // Only continue if WebGL is available and working
  if (gl === null) {
    alert(
      "Unable to initialize WebGL. Your browser or machine may not support it.",
    );
  }

  // Vertex shader program
  const vsSource = /*glsl*/`# version 300 es

    in vec4 aVertexPosition;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    out vec2 v_pos;

    void main() {
      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      v_pos = aVertexPosition.xy;
    }
  `;

  const circleFrag = /*glsl*/ `# version 300 es
    precision mediump float;

    #define PI 3.14159265359

    in vec2 v_pos;

    uniform vec3 color;
    uniform float strokeWidth;

    const vec3 BLACK = vec3( 0.0 );

    out vec4 outColor;

    void main() {
      float dist = distance( vec2( 0.0, 0.0 ), v_pos.xy );

      // NOTE: We're covering darker shading with the stroke if we do it this way...need to fix for legs, too
      if ( dist < 0.5 - strokeWidth ) {
        outColor = vec4( mix( BLACK, color, cos( 0.8 * PI * dist ) ), 1.0 );
      }
      else if ( dist < 0.5 ) {
        outColor = vec4( BLACK, 1.0 );
      }
      else {
        discard;
      }
    }
  `;

  const triangleFrag = /*glsl*/ `# version 300 es
    precision mediump float;

    #define PI 3.14159265359

    in vec2 v_pos;

    uniform vec3 color;
    uniform float strokeWidth;

    out vec4 outColor;

    void main() {
      float dist = v_pos.x - abs( v_pos.y );

      if ( dist > strokeWidth && v_pos.x < 1.0 - strokeWidth / 2.0 ) {
        outColor = vec4( mix( vec3( 0.0 ), color, dist ), 1.0 );
      }
      else {
        outColor = vec4( 0.0, 0.0, 0.0, 1.0 );
      }
    }
  `;

  // Initialize a shader program; this is where all the lighting
  // for the vertices and so forth is established.
  const circleShader = initShaderProgram( gl, vsSource, circleFrag );

  // Collect all the info needed to use the shader program.
  // Look up which attribute our shader program is using
  // for aVertexPosition and look up uniform locations.
  const circleProgramInfo = {
    program: circleShader,
    attribLocations: {
      vertexPosition: gl.getAttribLocation(circleShader, "aVertexPosition"),
    },
    uniformLocations: {
      projectionMatrix: gl.getUniformLocation(circleShader, "uProjectionMatrix"),
      modelViewMatrix: gl.getUniformLocation(circleShader, "uModelViewMatrix"),
      color: gl.getUniformLocation( circleShader, "color" ),
      strokeWidth: gl.getUniformLocation( circleShader, "strokeWidth" ),
    },
  };

  const triangleShader = initShaderProgram( gl, vsSource, triangleFrag );

  const triangleProgramInfo = {
    program: triangleShader,
    attribLocations: {
      vertexPosition: gl.getAttribLocation(triangleShader, "aVertexPosition"),
    },
    uniformLocations: {
      projectionMatrix: gl.getUniformLocation(triangleShader, "uProjectionMatrix"),
      modelViewMatrix: gl.getUniformLocation(triangleShader, "uModelViewMatrix"),
      color: gl.getUniformLocation( triangleShader, "color" ),
      strokeWidth: gl.getUniformLocation( triangleShader, "strokeWidth" ),
    },
  };

  // Here's where we call the routine that builds all the
  // objects we'll be drawing.
  const buffers = initBuffers(gl);

  // TODO: Create buffer for triangles

  let animationTime = 0;

  function drawScene(gl, buffers) {
    gl.clearColor(0.0, 0.0, 0.5, 1.0);
    gl.clearDepth(1.0); // Clear everything
    gl.enable(gl.DEPTH_TEST); // Enable depth testing
    gl.depthFunc(gl.LEQUAL); // Near things obscure far things

    // Clear the canvas before we start drawing on it.

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Create a perspective matrix, a special matrix that is
    // used to simulate the distortion of perspective in a camera.
    // Our field of view is 45 degrees, with a width/height
    // ratio that matches the display size of the canvas
    // and we only want to see objects between 0.1 units
    // and 100 units away from the camera.

    const fieldOfView = 45 * Math.PI / 180; // in radians
    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
    const zNear = 0.1;
    const zFar = 100.0;
    const projectionMatrix = mat4.create();

    // note: glmatrix.js always has the first argument
    // as the destination to receive the result.
    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);


    for ( let row = 0; row < 5; row ++ ) {
      for ( let col = 0; col < 6; col ++ ) {
        // Tell WebGL to use our program when drawing
        gl.useProgram(circleProgramInfo.program);

        // Tell WebGL how to pull out the positions from the position
        // buffer into the vertexPosition attribute.
        setPositionAttribute(gl, buffers.circlePositions, circleProgramInfo);

        // Set the shader uniforms
        gl.uniformMatrix4fv(
          circleProgramInfo.uniformLocations.projectionMatrix,
          false,
          projectionMatrix,
        );

        const modelViewMatrix = mat4.fromRotationTranslationScale( 
          mat4.create(), 
          [ Math.cos( animationTime / 2 ), Math.sin( animationTime / 2 ), 0, 0 ],
          [ -2.5 + col, -2 + row, -6 ],
          [ 0.8, 0.8, 0.8 ],
        );

        gl.uniformMatrix4fv(
          circleProgramInfo.uniformLocations.modelViewMatrix,
          false,
          modelViewMatrix,
        );

        const shellColor = new Float32Array( [ 0.25, 0.5, 0.25 ] );
        gl.uniform3fv( circleProgramInfo.uniformLocations.color, shellColor );
        gl.uniform1f( circleProgramInfo.uniformLocations.strokeWidth, 0.05 );

        gl.drawArrays( gl.TRIANGLE_STRIP, 0 /* first */, 4 /* count */ );

        const headMatrix = mat4.fromRotationTranslationScale( 
          mat4.create(), 
          [ 0, 0, 0, 0 ],
          [ 0.5, 0, 0 ],
          [ 0.5, 0.5, 0.5 ],
        );

        gl.uniformMatrix4fv(
          circleProgramInfo.uniformLocations.modelViewMatrix,
          false,
          mat4.multiply( mat4.create(), modelViewMatrix, headMatrix ),
        );

        const bodyColor = new Float32Array( [ 0.0, 0.5, 0 ] );
        gl.uniform3fv( circleProgramInfo.uniformLocations.color, bodyColor );
        gl.uniform1f( circleProgramInfo.uniformLocations.strokeWidth, 0.1 );


        gl.drawArrays( gl.TRIANGLE_STRIP, 0 /* first */, 4 /* count */ );

        // Legs

        // Tell WebGL to use our program when drawing
        gl.useProgram(triangleProgramInfo.program);
        
        setPositionAttribute(gl, buffers.trianglePositions, triangleProgramInfo);

        // Set the shader uniforms
        gl.uniformMatrix4fv(
          triangleProgramInfo.uniformLocations.projectionMatrix,
          false,
          projectionMatrix,
        );

        const legMatrix = mat4.fromRotationTranslationScale( 
          mat4.create(), 
          [ Math.cos( animationTime / 2 ), Math.sin( animationTime / 2 ), 0, 0 ],
          [ 0, 0, 0 ],
          [ 0.5, 0.25, 0.5 ],
        );

        gl.uniformMatrix4fv(
          triangleProgramInfo.uniformLocations.modelViewMatrix,
          false,
          mat4.multiply( mat4.create(), modelViewMatrix, legMatrix ),
        );

        gl.uniform3fv( triangleProgramInfo.uniformLocations.color, bodyColor );
        gl.uniform1f( triangleProgramInfo.uniformLocations.strokeWidth, 0.1 );


        gl.drawArrays( gl.TRIANGLE_STRIP, 0 /* first */, 3 /* count */ );

      }
    }
  }

  function update( dt ) {
    animationTime += dt / 1000;
  }

  let lastTime;
  function render( now ) {
    lastTime ??= now;  // for first call only
    update( now - lastTime );
    lastTime = now;

    // Draw the scene
    drawScene(gl, buffers);

    requestAnimationFrame( render );
  }

  requestAnimationFrame( render );

  // Tell WebGL how to pull out the positions from the position
  // buffer into the vertexPosition attribute.
  function setPositionAttribute( gl, buffer, programInfo ) {
    gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
    gl.vertexAttribPointer( programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0 );
    gl.enableVertexAttribArray( programInfo.attribLocations.vertexPosition );
  }

  //
  // Initialize a shader program, so WebGL knows how to draw our data
  //
  function initShaderProgram(gl, vsSource, fsSource) {
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    // Create the shader program

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    // If creating the shader program failed, alert

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert(
        `Unable to initialize the shader program: ${gl.getProgramInfoLog(
          shaderProgram,
        )}`,
      );
      return null;
    }

    return shaderProgram;
  }

  //
  // creates a shader of the given type, uploads the source and
  // compiles it.
  //
  function loadShader(gl, type, source) {
    const shader = gl.createShader(type);

    // Send the source to the shader object

    gl.shaderSource(shader, source);

    // Compile the shader program

    gl.compileShader(shader);

    // See if it compiled successfully

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert(
        `An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`,
      );
      gl.deleteShader(shader);
      return null;
    }

    return shader;
  }


  function initBuffers(gl) {
    return {
      circlePositions: initBuffer( gl, [
         0.5,  0.5, 
        -0.5,  0.5, 
         0.5, -0.5, 
        -0.5, -0.5,
      ] ),
      trianglePositions: initBuffer( gl, [
         0.0,  0.0,
         1, -1,
         1,  1,
      ] ),
    };
  }

  function initBuffer( gl, positions ) {
    const buffer = gl.createBuffer();
    gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
    gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( positions ), gl.STATIC_DRAW );
    return buffer;
  }


</script>