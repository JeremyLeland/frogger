<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebGL Demo</title>
  </head>

  <body>
    <canvas id="glcanvas"></canvas>
  </body>
</html>

<script type="module">
  import { mat4 } from '../lib/gl-matrix.js';

  const width = 800, height = 600;
  const canvas = document.querySelector("#glcanvas");
  canvas.width = width * devicePixelRatio;
  canvas.height = height * devicePixelRatio;
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';

  // Initialize the GL context
  const gl = canvas.getContext("webgl2");

  // Only continue if WebGL is available and working
  if (gl === null) {
    alert(
      "Unable to initialize WebGL. Your browser or machine may not support it.",
    );
  }

  // Vertex shader program
  const vsSource = /*glsl*/`# version 300 es

    in vec4 aVertexPosition;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    out vec2 v_pos;

    void main() {
      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      v_pos = aVertexPosition.xy;
    }
  `;

  const circleFrag = /*glsl*/ `# version 300 es
    precision mediump float;

    #define PI 3.14159265359

    in vec2 v_pos;

    uniform vec3 color;
    uniform float strokeWidth;

    const vec3 BLACK = vec3( 0.0 );

    out vec3 outColor;

    void main() {
      float dist = distance( vec2( 0.0, 0.0 ), v_pos.xy );

      // NOTE: We're covering darker shading with the stroke if we do it this way...need to fix for legs, too
      if ( dist < 0.5 - strokeWidth ) {
        outColor = mix( BLACK, color, cos( 0.8 * PI * dist ) );
      }
      else if ( dist < 0.5 ) {
        outColor = BLACK;
      }
      else {
        discard;
      }
    }
  `;

  // Initialize a shader program; this is where all the lighting
  // for the vertices and so forth is established.
  const circleShader = initShaderProgram( gl, vsSource, circleFrag );

  // Collect all the info needed to use the shader program.
  // Look up which attribute our shader program is using
  // for aVertexPosition and look up uniform locations.
  const programInfo = {
    program: circleShader,
    attribLocations: {
      vertexPosition: gl.getAttribLocation(circleShader, "aVertexPosition"),
    },
    uniformLocations: {
      projectionMatrix: gl.getUniformLocation(circleShader, "uProjectionMatrix"),
      modelViewMatrix: gl.getUniformLocation(circleShader, "uModelViewMatrix"),
      color: gl.getUniformLocation( circleShader, "color" ),
      strokeWidth: gl.getUniformLocation( circleShader, "strokeWidth" ),
    },
  };

  // Here's where we call the routine that builds all the
  // objects we'll be drawing.
  const buffers = initBuffers(gl);

  let animationTime = 0;

  function drawScene(gl, programInfo, buffers) {
    gl.clearColor(0.0, 0.0, 0.5, 1.0); // Clear to black, fully opaque
    gl.clearDepth(1.0); // Clear everything
    gl.enable(gl.DEPTH_TEST); // Enable depth testing
    gl.depthFunc(gl.LEQUAL); // Near things obscure far things

    // Clear the canvas before we start drawing on it.

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Create a perspective matrix, a special matrix that is
    // used to simulate the distortion of perspective in a camera.
    // Our field of view is 45 degrees, with a width/height
    // ratio that matches the display size of the canvas
    // and we only want to see objects between 0.1 units
    // and 100 units away from the camera.

    const fieldOfView = 45 * Math.PI / 180; // in radians
    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
    const zNear = 0.1;
    const zFar = 100.0;
    const projectionMatrix = mat4.create();

    // note: glmatrix.js always has the first argument
    // as the destination to receive the result.
    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

    // Tell WebGL how to pull out the positions from the position
    // buffer into the vertexPosition attribute.
    setPositionAttribute(gl, buffers, programInfo);

    // Tell WebGL to use our program when drawing
    gl.useProgram(programInfo.program);

    // Set the shader uniforms
    gl.uniformMatrix4fv(
      programInfo.uniformLocations.projectionMatrix,
      false,
      projectionMatrix,
    );

    for ( let row = 0; row < 5; row ++ ) {
      for ( let col = 0; col < 6; col ++ ) {
        // Set the drawing position to the "identity" point, which is
        // the center of the scene.
        const modelViewMatrix = mat4.create();

        // Now move the drawing position a bit to where we want to
        // start drawing the square.
        mat4.translate(
          modelViewMatrix, // destination matrix
          modelViewMatrix, // matrix to translate
          [-2.5 + col, -2 + row, -6.0],
        ); // amount to translate

        mat4.rotate(
          modelViewMatrix,
          modelViewMatrix,
          animationTime, 
          [ 0, 0, 1 ],
        );

        mat4.scale(
          modelViewMatrix,
          modelViewMatrix,
          [ 0.4, 0.4, 0.4 ],
        )

        gl.uniformMatrix4fv(
          programInfo.uniformLocations.modelViewMatrix,
          false,
          modelViewMatrix,
        );

        const shellColor = new Float32Array( [ 0.25, 0.5, 0.25 ] );
        gl.uniform3fv( programInfo.uniformLocations.color, shellColor );
        gl.uniform1f( programInfo.uniformLocations.strokeWidth, 0.05 );

        gl.drawArrays( gl.TRIANGLE_STRIP, 0 /* first */, 4 /* count */ );

        mat4.translate(
          modelViewMatrix, // destination matrix
          modelViewMatrix, // matrix to translate
          [ 0.5, 0, 0 ],
        );

        mat4.scale(
          modelViewMatrix, // destination matrix
          modelViewMatrix, // matrix to translate
          [ 0.5, 0.5, 0.5 ],
        );

        gl.uniformMatrix4fv(
          programInfo.uniformLocations.modelViewMatrix,
          false,
          modelViewMatrix,
        );

        const headColor = new Float32Array( [ 0.0, 0.5, 0 ] );
        gl.uniform3fv( programInfo.uniformLocations.color, headColor );
        gl.uniform1f( programInfo.uniformLocations.strokeWidth, 0.1 );


        gl.drawArrays( gl.TRIANGLE_STRIP, 0 /* first */, 4 /* count */ );
      }
    }
  }

  function update( dt ) {
    animationTime += dt / 1000;
  }

  let lastTime;
  function render( now ) {
    lastTime ??= now;  // for first call only
    update( now - lastTime );
    lastTime = now;

    // Draw the scene
    drawScene(gl, programInfo, buffers);

    requestAnimationFrame( render );
  }

  requestAnimationFrame( render );

  // Tell WebGL how to pull out the positions from the position
  // buffer into the vertexPosition attribute.
  function setPositionAttribute(gl, buffers, programInfo) {
    const numComponents = 2; // pull out 2 values per iteration
    const type = gl.FLOAT; // the data in the buffer is 32bit floats
    const normalize = false; // don't normalize
    const stride = 0; // how many bytes to get from one set of values to the next
    // 0 = use type and numComponents above
    const offset = 0; // how many bytes inside the buffer to start from
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
    gl.vertexAttribPointer(
      programInfo.attribLocations.vertexPosition,
      numComponents,
      type,
      normalize,
      stride,
      offset,
    );
    gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
  }

  //
  // Initialize a shader program, so WebGL knows how to draw our data
  //
  function initShaderProgram(gl, vsSource, fsSource) {
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    // Create the shader program

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    // If creating the shader program failed, alert

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert(
        `Unable to initialize the shader program: ${gl.getProgramInfoLog(
          shaderProgram,
        )}`,
      );
      return null;
    }

    return shaderProgram;
  }

  //
  // creates a shader of the given type, uploads the source and
  // compiles it.
  //
  function loadShader(gl, type, source) {
    const shader = gl.createShader(type);

    // Send the source to the shader object

    gl.shaderSource(shader, source);

    // Compile the shader program

    gl.compileShader(shader);

    // See if it compiled successfully

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert(
        `An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`,
      );
      gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  function initBuffers(gl) {
    const positionBuffer = initPositionBuffer(gl);

    return {
      position: positionBuffer,
    };
  }

  function initPositionBuffer(gl) {
    // Create a buffer for the square's positions.
    const positionBuffer = gl.createBuffer();

    // Select the positionBuffer as the one to apply buffer
    // operations to from here out.
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    // Now create an array of positions for the square.
    const positions = [
       1.0,  1.0, 
      -1.0,  1.0, 
       1.0, -1.0, 
      -1.0, -1.0
    ];

    // Now pass the list of positions into WebGL to build the
    // shape. We do this by creating a Float32Array from the
    // JavaScript array, then use it to fill the current buffer.
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    return positionBuffer;
  }


</script>