<title>Test drawing methods</title>
<link rel="stylesheet" href="../ui.css">

<label for="count">Count:</label>
<input type="range" id="count" name="count" min="0" max="1000" value="500"/>

<script type="module">
  import { AnimatedCanvas } from '../src/common/AnimatedCanvas.js';

  const canvas = new AnimatedCanvas();
  const countUI = document.getElementById( 'count' );

  const entities = [];

  function setCount( count ) {
    entities.splice( count );

    for ( let i = entities.length; i < count; i ++ ) {
      entities.push(
        {
          x: Math.floor( Math.random() * 100 ),
          y: Math.floor( Math.random() * 100 ), 
          angle: Math.random() * 360
          // angle: Math.random() * 6
        }
      );
    }    
  }

  countUI.addEventListener( 'change', _ => setCount( countUI.valueAsNumber ) );
  
  countUI.dispatchEvent( new Event( 'change' ) );

  canvas.update = ( dt ) => {
    entities.forEach( e => {
      e.angle += dt / 1000;
      //e.angle += dt / 10;
    } );
  }

  const path = new Path2D();
  path.ellipse( 0, 0, 2, 1, 0, 0, Math.PI * 2 );
  
  canvas.draw = ( ctx ) => {

    ctx.clearRect( 0, 0, ctx.canvas.width, ctx.canvas.height );

    ctx.save();
    ctx.scale( 10, 10 );

    // ctx.beginPath();
    // const combined = new Path2D();

    const gradient = ctx.createRadialGradient( 0, 0, 0, 0, 0, 1 );

    // Add three color stops
    gradient.addColorStop(0, "darkolivegreen");
    gradient.addColorStop(1, "black");

    ctx.fillStyle = gradient;

    entities.forEach( e => {
      ctx.save();
      
      ctx.translate( e.x, e.y );
      ctx.rotate( e.angle );

      
      // let transform = new DOMMatrix();
      // transform.translateSelf( e.x, e.y );
      // transform.rotateSelf( e.angle );

      // combined.addPath( path, transform );

      ctx.beginPath();
      // ctx.moveTo( 0, 0 );

      // ctx.rect( -2, -1, 4, 2 );

      // ctx.lineTo( -2, -1 );
      // ctx.lineTo(  2, -1 );
      // ctx.lineTo(  3,  0 );
      // ctx.lineTo(  2,  1 );
      // ctx.lineTo( -2,  1 );
      // ctx.lineTo( -3,  0 );
      // ctx.lineTo( -2, -1 );

      // ctx.ellipse( 0, 0, 2, 1, 0, 0, Math.PI * 2 );
      //ctx.fill( path );

      // for ( let angle = 0; angle <= Math.PI * 2; angle += Math.PI / 3 ) {
      //   ctx.lineTo( Math.cos( angle ) * 2, Math.sin( angle ) * 1 );
      // }
      

      ctx.fillRect( -1, -1, 2, 2 );
      // ctx.rect( -1, -1, 2, 2 );
      // ctx.moveTo( 0, 0 );
      // ctx.arc( 0, 0, 1, 0, Math.PI * 2 );

      // ctx.fill();

      ctx.restore();
    } );

    // ctx.fillStyle = 'green';
    // ctx.filter = 'blur(5px)';

    // ctx.fill( combined );
    ctx.fill( );
    // ctx.stroke();

    ctx.restore();
  };

  canvas.start();

</script>