<link rel="stylesheet" href="../grid.css">

<script type="module">
  import * as THREE from '../lib/three.module.js';
  import * as MeshDemo from './meshDemo.js';


  const vert = /* glsl */ `
    out vec2 v_pos;
    
    void main() {
      v_pos = position.xy;
      
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
  `;

  const frag = /* glsl */ `
    #define PI 3.14159265359

    in vec2 v_pos;

    out vec3 outColor;

    uniform vec2 P0, P1, P2;
    uniform float startWidth, endWidth;
    uniform vec3 color;
    uniform float strokeWidth;

    float cubeRoot( float val ) {
      float fixNeg = val < 0.0 ? -1.0 : 1.0;
      return fixNeg * pow( fixNeg * val, 1.0 / 3.0 );
    }

    vec2 getPos( float t ) {
      float a = ( 1.0 - t ) * ( 1.0 - t );
      float b = 2.0 * t * ( 1.0 - t );
      float c = t * t;

      return a * P0 + b * P1 + c * P2;
    }

    // See: https://blog.gludion.com/2009/08/distance-to-quadratic-bezier-curve.html
    void main() {
      vec2 A = P1 - P0;
      vec2 B = P2 - P1 - A;

      vec2 MP = P0 - v_pos;

      float a1 = dot( B, B );
      float b = 3.0 * dot( A, B );
      float c = 2.0 * dot( A, A ) + dot( MP, B );
      float d = dot( MP, A );

      float a = b / a1;
      b = c / a1;
      c = d / a1;

      float p = -( a * a / 3.0 ) + b;
      float q = ( 2.0 / 27.0 ) * a * a * a  - ( a * b / 3.0 ) + c;
      float disc = q * q + 4.0 * p * p * p / 27.0;
      float offset = -a / 3.0;
      
      float root = 0.0;
      float dist = 0.0;
      // vec3 color;


      if ( disc > 0.0 ) {
        float u = cubeRoot( ( -q + sqrt( disc ) ) / 2.0 );
        float v = cubeRoot( ( -q - sqrt( disc ) ) / 2.0 );

        root = clamp( u + v + offset, 0.0, 1.0 );

        dist = distance( getPos( root ), v_pos );
        // color = vec3( 1.0, 0.0, 0.0 );
      }

      else if ( disc == 0.0 ) {
        float u = cubeRoot( -q / 2.0 );

        root = clamp( 2.0 * u + offset, 0.0, 1.0 );
        
        // TODO: wait, another root here? Need to do dist check loop here too?
        //       seems like we never really hit this case anyway...
        root = clamp( -u + offset, 0.0, 1.0 );

        dist = distance( getPos( root ), v_pos );

        // color = vec3( 0.0, 1.0, 0.0 );
      }

      else {
        float u = 2.0 * sqrt( -p / 3.0 );
        float v = acos( -sqrt( -27.0 / ( p * p * p ) ) * q / 2.0 ) / 3.0;

        
        for ( float i = 0.0; i <= 4.0; i += 2.0 ) {
          float testRoot = clamp( u * cos( v + i * PI / 3.0 ) + offset, 0.0, 1.0 );
          float testDist = distance( getPos( testRoot ), v_pos );

          if ( i == 0.0 || testDist < dist ) {
            root = testRoot;
            dist = testDist;
          }
        }

        // color = vec3( 0.0, 0.0, 1.0 );
      }


      float width = endWidth + ( 1.0 - root ) * ( startWidth - endWidth );
     
      if ( dist < width ) {
        outColor = mix( vec3( 0.0 ), color, cos( PI / 2.0 * dist / width ) );
      }
      else if ( dist < width + strokeWidth ) {
        outColor = vec3( 0.0 );
      }
      else {
        discard;
      }
    }
  `;


  let animationTime = 0;

  const FOOT_X = 0.4, FOOT_Y = 0.4, FOOT_SIZE = 0.05;
  const LEG_X = 0.05, LEG_Y = 0.1, LEG_SIZE = 0.1;

  const frontLeftUniforms = {
    P0: { value: new THREE.Vector2( LEG_X, -LEG_Y ) },
    P1: { value: new THREE.Vector2( LEG_X, -FOOT_Y ) },
    P2: { value: new THREE.Vector2( FOOT_X, -FOOT_Y ) },
    startWidth:  { value: LEG_SIZE },
    endWidth:    { value: FOOT_SIZE },
    color: { value: new THREE.Vector3( 0, 0.5, 0 ) },
    strokeWidth: { value: 0.02 },
  };

  const frontRightUniforms = {
    P0: { value: new THREE.Vector2( LEG_X, LEG_Y ) },
    P1: { value: new THREE.Vector2( LEG_X, FOOT_Y ) },
    P2: { value: new THREE.Vector2( FOOT_X, FOOT_Y ) },
    startWidth:  { value: LEG_SIZE },
    endWidth:    { value: FOOT_SIZE },
    color: { value: new THREE.Vector3( 0, 0.5, 0 ) },
    strokeWidth: { value: 0.02 },
  };

  const backLeftUniforms = {
    P0: { value: new THREE.Vector2( -LEG_X, -LEG_Y ) },
    P1: { value: new THREE.Vector2( -LEG_X, -FOOT_Y ) },
    P2: { value: new THREE.Vector2( -FOOT_X, -FOOT_Y ) },
    startWidth:  { value: LEG_SIZE },
    endWidth:    { value: FOOT_SIZE },
    color: { value: new THREE.Vector3( 0, 0.5, 0 ) },
    strokeWidth: { value: 0.02 },
  };

  const backRightUniforms = {
    P0: { value: new THREE.Vector2( -LEG_X, LEG_Y ) },
    P1: { value: new THREE.Vector2( -LEG_X, FOOT_Y ) },
    P2: { value: new THREE.Vector2( -FOOT_X, FOOT_Y ) },
    startWidth:  { value: LEG_SIZE },
    endWidth:    { value: FOOT_SIZE },
    color: { value: new THREE.Vector3( 0, 0.5, 0 ) },
    strokeWidth: { value: 0.02 },
  };

  const frontLeftLegs = new THREE.Mesh(
    new THREE.PlaneGeometry( 1.5, 1 ),
    new THREE.ShaderMaterial( {
      uniforms: frontLeftUniforms,
      vertexShader: vert,
      fragmentShader: frag,
      glslVersion: THREE.GLSL3,
    } )
  );

  const frontRightLegs = new THREE.Mesh(
    new THREE.PlaneGeometry( 1.5, 1 ),
    new THREE.ShaderMaterial( {
      uniforms: frontRightUniforms,
      vertexShader: vert,
      fragmentShader: frag,
      glslVersion: THREE.GLSL3,
    } )
  );

  const backLeftLegs = new THREE.Mesh(
    new THREE.PlaneGeometry( 1.5, 1 ),
    new THREE.ShaderMaterial( {
      uniforms: backLeftUniforms,
      vertexShader: vert,
      fragmentShader: frag,
      glslVersion: THREE.GLSL3,
    } )
  );

  const backRightLegs = new THREE.Mesh(
    new THREE.PlaneGeometry( 1.5, 1 ),
    new THREE.ShaderMaterial( {
      uniforms: backRightUniforms,
      vertexShader: vert,
      fragmentShader: frag,
      glslVersion: THREE.GLSL3,
    } )
  );

  // frontLegs.position.y = 0.4;
  // backLegs.position.y = -0.4;
  
  const circleFrag = /*glsl*/ `
    #define PI 3.14159265359

    in vec2 v_pos;

    uniform vec3 color;
    uniform float strokeWidth;

    const vec3 BLACK = vec3( 0.0 );

    out vec3 outColor;

    void main() {
      float dist = distance( vec2( 0.0, 0.0 ), v_pos.xy );

      // NOTE: We're covering darker shading with the stroke if we do it this way...need to fix for legs, too
      if ( dist < 0.5 - strokeWidth ) {
        outColor = mix( BLACK, color, cos( 0.8 * PI * dist ) );
      }
      else if ( dist < 0.5 ) {
        outColor = BLACK;
      }
      else {
        discard;
      }
    }
  `;

  const BODY_SIZE = 0.8;

  const body = new THREE.Mesh(
    new THREE.PlaneGeometry( 1, 1 ),
    new THREE.ShaderMaterial( {
      uniforms: {
        color: { value: new THREE.Vector3( 0, 0.5, 0 ) },
        strokeWidth: { value: 0.03 },
      },
      vertexShader: vert,
      fragmentShader: circleFrag,
      glslVersion: THREE.GLSL3,
    } ),
  );

  body.scale.set( BODY_SIZE, BODY_SIZE, 1 );


  const EYE_OFFSET_X = 0.18, EYE_OFFSET_Y = 0.17;
  const EYE_SIZE = 0.2;

  const PUPIL_OFFSET_X = 0.23, PUPIL_OFFSET_Y = 0.17;
  const PUPIL_W = 0.1, PUPIL_H = 0.16;

  const eyes = [ -1, 1 ].map( offsetY => {
    const mesh = new THREE.Mesh(
      new THREE.PlaneGeometry( 1, 1 ),
      new THREE.ShaderMaterial( {
        uniforms: {
          color: { value: new THREE.Vector3( 1, 1, 1 ) },
          strokeWidth: { value: 0.1 },
        },
        vertexShader: vert,
        fragmentShader: circleFrag,
        glslVersion: THREE.GLSL3,
      } ),
    );

    mesh.position.set( EYE_OFFSET_X, offsetY * EYE_OFFSET_Y, 0 );
    mesh.scale.set( EYE_SIZE, EYE_SIZE, 1 );

    return mesh;
  } );

  const pupils = [ -1, 1 ].map( offsetY => {
    const mesh = new THREE.Mesh(
      new THREE.PlaneGeometry( 1, 1 ),
      new THREE.ShaderMaterial( {
        uniforms: {
          color: { value: new THREE.Vector3( 0, 0, 0 ) },
          strokeWidth: { value: 0.03 },
        },
        vertexShader: vert,
        fragmentShader: circleFrag,
        glslVersion: THREE.GLSL3,
      } ),
    );

    mesh.position.set( PUPIL_OFFSET_X, offsetY * PUPIL_OFFSET_Y, 0 );
    mesh.scale.set( PUPIL_W, PUPIL_H, 1 );

    return mesh;
  } );

  const group = new THREE.Group();
  group.add( frontLeftLegs, frontRightLegs, backLeftLegs, backRightLegs, body, ...eyes, ...pupils );
    
  MeshDemo.meshDemo( 
    group, 
    ( dt ) => {
      animationTime += dt / 100;
      // frontUniforms.magnitude.value = 0.75 + 0.25 * Math.sin( animationTime );
      // backUniforms.magnitude.value = -1 + 0.25 * Math.sin( animationTime );

      frontLeftUniforms.P2.value.x = FOOT_X - 0.05 + 0.05 * Math.sin( animationTime );
      frontRightUniforms.P2.value.x = FOOT_X - 0.05 + 0.05 * Math.sin( animationTime );
      backLeftUniforms.P2.value.x = backRightUniforms.P2.value.x = -FOOT_X - 0.05 + 0.05 * Math.sin( animationTime );
    }
  );

</script>
